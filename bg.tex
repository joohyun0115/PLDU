\section{Background and Problem}

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
% Paragraph 1: Linux Scalability : Fork intensive workload 문제점 설명 
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\ifkor
\begin{figure}
  \begin{subfigure}[b]{0.23\textwidth}
    \includegraphics[width=\textwidth]{graph/aim7_default}
    \caption{aa}
  \end{subfigure}%
  \begin{subfigure}[b]{0.25\textwidth}
    \includegraphics[width=\textwidth]{graph/lockstat}
    \caption{aa}
  \end{subfigure}
  \centering
  \caption{Scalability of AIM7 multiuser. This workload simultaneously create
  many processes.
  Up to 60 core, the stock Linux scale linearly, then they flattens out.}
  \label{fig:aim7_default}
\end{figure}

운영체제 커널의 paralleism은 시스템 전체의 parallesim에서 가장 중요하다. 
만약에 커널이 scale하지 않으면, 그 위에 동작하는 응용프로그램들도 역시 scale하지 않는다~\cite{Clements15SCR}.
우리는 이처럼 중요한 부분인 운영체제 커널중 multi-core에 최적화된 리눅스의 scalabiliy를 분석하기 위해, AIM7
multiuser[]를 가지고 scalability를 실험해보았다.
AIM7은 최근에도 scalability를 위해 reserach 진영과 리눅스 커널 진영에서도 활발히 사용되고 있는 벤치마크 중
하나이다~\cite{Bueso2015STP}~\cite{Bueso2014MCS}.
AIM7-multiuser 워크로드는 동시에 많은 프로세스를 생성하며 수행되며, 디스크 파일 오퍼레이션, 가상 메모리 오퍼레이션, 파이프
I/O 그리고 수학 연산과 함께 수행한다.
File system scalability를 최소화 하기 위해 temp filesystem~\cite{Rohland2001Tempfs}을
사용하였다.
실험 결과 60코어 까지는 확장성이 있으나 그 이후에는 확장성이 떨어져 완만한 그래프를 보여준다. 

\else

\begin{figure}
  \begin{subfigure}[b]{0.23\textwidth}
    \includegraphics[width=\textwidth]{graph/aim7_default}
    \caption{aa}
  \end{subfigure}%
  \begin{subfigure}[b]{0.25\textwidth}
    \includegraphics[width=\textwidth]{graph/lockstat}
    \caption{aa}
  \end{subfigure}
  \centering
  \caption{Scalability of AIM7 multiuser. This workload simultaneously create
  many processes.
  Up to 60 core, the stock Linux scale linearly, then they flattens out.}
  \label{fig:aim7_default}
\end{figure}


%운영체제 커널의 paralleism은 시스템 전체의 parallesim에서 가장 중요하다. 
% Sentence #1:
Operating system paralleism is of utmost importance for scalable systems
%만약에 커널이 scale하지 않으면, 그 위에 동작하는 응용프로그램들도 역시 scale하지 않는다~\cite{Clements15SCR}.
% Sentence #1:
Aplications performance would be limited by the operating system when the
operating system doesn't scale~\cite{Clements15SCR}[Corey].
% 리눅스는 멀티코어에 최적회된 운영체에 최적화 되어 있기 때문에, 우리는 리눅스에서 AIM7-multiuser를 사용하여
%분석해 보았다.
% Sentence #1:
Because Linux has heavily optimized for multi-core operating system, we examine
AIM7-multiuser benchmark on Linux.
%AIM7 벤치마크는 최근에도 scalability를 위해 reserach 진영과 리눅스 커널 진영에서도 활발히 이용된다.
% ~\cite{Bueso2015STP}~\cite{Bueso2014MCS}.
% Sentence #1:
AIM benchmark has, until recently, been heavily used in research area and Linux
community~\cite{Bueso2015STP}~\cite{Bueso2014MCS}.
%AIM7-multiuser 워크로드는 동시에 많은 프로세스를 생성하며 수행되며, 디스크 파일 오퍼레이션, 가상 메모리 오퍼레이션, 파이프
%I/O 그리고 수학 연산과 함께 수행한다.
AIM7-multiuser workload simultaneously create many processes with disk-file
operations, virtual memory operations, pipe I/O, and arithmetic operation. 
%File system scalability를 최소화 하기 위해 temp filesystem~\cite{Rohland2001Tempfs}을
%사용하였다.
% Sentence #1:
To minimaize file system bottleneck, we used temp
filesystem~\cite{Rohland2001Tempfs}.
The Figure-xx(a) show the scalability when running AIM7.
%실험 결과 60코어 까지, 리눅스 커널은 확장성이 있으나 그 이후에는 확장성이 떨어져 완만한 그래프를 보여준다. 
Up to 60 core, the stock Linux scale linearly, then they flattens out.
\fi

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
% Paragraph 2: Lockstat로 분석 결과 설명 
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\ifkor
우리는 Scalability에 문제가 있는 120코어에서 리눅스의 Lockstat[]를 이용하여 락 경합을 분석하였다. 
먼저 멀티 프로세스 기반의 벤치마크인 AIM7을 동작시키고 동시에 120코어 대해서 락 경합을 분석하면 
그림 3과 같은 결과를 가진다. 
AIM7 벤치마크의 경우 상당히 많은 부분이 anonvma에서 쓰기 락 경합이 발생한다. 
이는 리눅스 역 매핑(reverse mapping)을 효율적으로 수행하기 위한 자료구인 anonvma가
수많은 fork에 의해 프로세스를 생성하면서 발생하는 락 경합 문제이다. 
이러한 revsers page mapping은 리눅스가 fork(), exit(), and mmap() 시스템콜을 사용할 때 페이지 정보를
update한다.
다음으로 우리는 anonvma의 lock 경합을 줄이기 위해, 임시로 fork에서 anonvma를 호출하는 부분과 read와
관련있는 pageswap이 안되도록 하고, 120코어를 대상으로 다시 Lock 경합을 분석하여 보았다.
이 때 부터 그동안 상대적으로 가려졌던 file reverse mapping에서 많은 락 경합이 발생되었다.
본 연구의 분석 결과 둘 중 하나가 아니라 두 가지 락 모두 fork의 scalabililty 문제를 야기 시킨다.
이러한 anonvma reverse page mapping은 리눅스 커뮤니티에서 잘 알려진 락 경합
문제~\cite{Andi2011adding}~\cite{Tim2013adding}이고, file mapping에 대한 락 경합 문제는
Silas wikizer가 OpLog 논문을 통해 fork의 scalability 문제의 원인으로 제시한 부분이다.
즉 두가지 모두 개선해야지 fork의 scalalbility가 향상 된다. 
\else

%우리는 Scalability에 문제가 있는 120코어에서 리눅스의 Lockstat[]를 이용하여 락 경합을 분석하였다. 
% Sentence #1:
To understand the source of scalability bottleneck on 120core, we profile a lock
contention using lock\_stat, a Linux kernel lock profiler that reports how long
each lock is held and the wait time to acquire the lock.
%먼저 멀티 프로세스 기반의 벤치마크인 AIM7을 동작시키고 동시에 120코어 대해서 락 경합을 분석하면 
%그림 3과 같은 결과를 가진다. 
% Sentence #1:
The Figure-xx (a) show the cost of acquiring the lock when running AIM7 on a
stock Linux kernel on the Intel 120 core machine.
%AIM7 벤치마크의 경우 상당히 많은 부분이 anonvma에서 쓰기 락 경합이 발생한다. 
% Sentence #1:
Using AIM7 benchmark, the stock Linux extremely high contend on anonymous
reverse page's read-writer sempaphore(anon\_vma->rwsem).
%이는 리눅스 역 매핑(reverse mapping)을 효율적으로 수행하기 위한 자료구인 anonvma가 수 많은 fork에 의해 프로세스를
% 생성하면서 발생하는 락 경합 문제이다.
% Sentence #1:
This lock contention generated by creating the number of process simontanously
with Linux fork.
%이러한 revsers page mapping은 리눅스가 fork(), exit(), and mmap() 시스템콜을 사용할 때 페이지 정보를
% update한다.
% Sentence #1:
These reverse page mapping records page information when using fork(),
exit() and mmap() system call to find all page table entries.
%다음으로 우리는 anonvma의 lock 경합을 줄이기 위해, 임시로 fork에서 anonvma를 호출하는 부분과 read와
%관련있는 pageswap이 안되도록 하고, 120코어를 대상으로 다시 Lock 경합을 분석하여 보았다.
% Sentence #1:
%Next we try to use a workaround that remove anon\_vma relative code in the part
%of the fork code with page-swap off avoiding the Linux page reclaiming.
% Sentence #2:
To understand the other bottleneck, we conducted a workaround by removing
anonymous rmap relative code in the part of the fork code with page-swap off
avoding the Linux page reclaiming.
%anon\_vma를 제거하면 리눅스는 file reverse mapping에서 많은 락 경합이 발생되었다.
% Sentence #1:
When removing the anon\_vma, Linux was contended on file reverse page
mapping(i\_mmaping-rwsem).


\fi

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
% Paragraph 3: 리눅스 reverse page map의 write serialization 문제점
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\ifkor
두가지 revserse page mapping의 근본적인 문제는 hight update operation에 대한 serialization 때문에
발생하는 문제이다.
Update는 execulucive lock을 통해 보호해야하기 때문에, update rate 높은 상황이 발생하면 리눅스
커널은 결국 lock에 의해 serialized되어 scalability가 떨어진다.
\else
%본 연구의 분석 결과 둘 중 하나가 아니라 두 가지 락 모두 fork의 scalabililty 문제를 야기 시킨다.
%이러한 anonvma reverse page mapping은 리눅스 커뮤니티에서 잘 알려진 락 경합
%문제~\cite{Andi2011adding}~\cite{Tim2013adding}이고, file mapping에 대한 락 경합 문제는
%Silas wikizer가 OpLog 논문을 통해 fork의 scalability 문제의 원인으로 제시한 부분이다.
% Sentence #1:
Resulting from our research, both anonymous reverse page mapping reporting
from Linux community[] and file reverse page mapping reporting
from S. Boyd-Wickizer[] are a significant factor in a fork scalability
problem.
%즉 두가지 모두 개선해야지 fork의 scalalbility가 향상 된다. 
Thus, in order to perfect scalability of the fork, both the
file reverse mapping and the anonymous reverse mapping should execute
concurrently without lock.
% Sentence #1:
%두가지 revserse page mapping의 근본적인 문제는 hight update operation에 대한 serialization
%때문에 발생하는 문제이다.
% Sentence #1:
More specifically, the fundamental scalability problem of reverse mapping is
their serialized updates operation because operating system kernel are serialized at the updates
operation.

%Update는 execulucive lock을 통해 보호해야하기 때문에, update rate 높은 상황이 발생하면 리눅스
%커널은 결국 lock에 의해 serialized되어 scalability가 떨어진다.
% Sentence #1:


\fi

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
% Paragraph 4: update heavy한 상황에 대한 설명과 해결 방법에 대한 설명
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\ifkor
이러한 high update rate이 발생하는 상황의 update serialization 문제에 대한 해결 방법들은 존재한다. 
해결 방법은 concurrent updates를 위한, non-blocking data structure와
log-based 알고리즘을 사용하는 방법이 있다.
Non-blocking algorithms들은 hardware synchronized atomic 연산들을 활용하여 current 하게
update와 read를 수행하게 만든 data structure이다.
하지만 shared memory global value를 multipul CAS로 접근하여 bottlenecks이 생긴다.
due to inter-core communication overheads~\cite{SilasBoydWickizerPth}.
최근에는 Deu to the multipul CAS, inter-core communication overheads를 줄인 log-based
방법들이 연구되고 있다.
우리의 LDU도 이러한 log-based 기반 방법 활용하였으며, log-based 방법에 대한 설명은 다음 장에서 자세히 다룬다.
\else

%이러한 high update rate이 발생하는 상황의 update serialization 문제에 대한 해결 방법들은 존재한다. 
% Sentence #1:
%해결 방법은 concurrent updates를 위한, non-blocking data structure와 log-based 알고리즘을
% 사용하는 방법이 있다.
% Sentence #1:
In order to achieve scalable concurrent updates allowing update operations to
proceed without update locks, both the non-blocking
algorithms~\cite{Harris2001Lockfree}~\cite{Fomitchev2004Lockfree}~\cite{Timnat2012}
and log-based algorithms are proposed.
%Non-blocking algorithms들은 hardware synchronized atomic 연산들을 활용하여 current 하게
%update와 read를 수행하게 만든 data structure이다.
% Sentence #1:
In non-blocking algorithms, when they observed against the current value in
global data structure such as list, queue and tree, they execute a CAS to
compare the against value.
When the value has been overridden, they must be retried later on.
%하지만 shared memory global value를 multipul CAS로 접근하여 bottlenecks이 생긴다.
%due to inter-core communication overheads~\cite{SilasBoydWickizerPth}.
% Sentence #1:
Consequently, both repeated CAS operation and their iteration loop caused
by CAS fails will result in bottlenecks due to inter-core communication
overheads~\cite{SilasBoydWickizerPth}.
%최근에는 Deu to the multipul CAS, inter-core communication overheads를 줄인 log-based
%방법들이 연구되고 있다.
% Sentence #1:
To overcome the issues caused by cache coherence systems, log-based methods are
proposed.
%우리의 LDU도 이러한 log-based 기반 방법 활용하였으며, log-based 방법에 대한 설명은 다음 장에서 자세히 다룬다.
% Sentence #1:
This paper presents a log-based deferred design that alows concurrent updates to
scale, so that multiprocessed applications can scale to large numbers of cores.
\fi


%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Reference Sentence 1
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$






%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Reference Sentence 2:LDU paper
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$




