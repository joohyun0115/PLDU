\section{Detail Implementation}\label{sec:implementation}

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Paragraph 1: 커널 버전 및 코드 분량, 테스트에 대한 설명
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
\ifkor
We implemented the new deferred update algorithm in Linux 4.5.rc6 kernel, and
our modified Linux is available as open source. 
global queue를 사용한 버전일 경우 코드의 수정량은 xx-xx을 가지며 덜 복잡한 구조이며, 
percore를 사용할 경우 코드 수정량은 xx-xx을 가진다. 
\else
We implemented the new deferred update algorithm in Linux 4.5.rc6 kernel, and
our modified Linux is available as open source. 
The version of global queue modified code is xx that less complex, but per-core
queue the modified code is xx-xx.
\fi

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Paragraph 2: per-core queue 구현에 대한 설명 
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
\ifkor
LDU percore queue는 2가지 방법으로 구현되었다. 
첫번째 방법은 percore hash table로 구현하는 방법이다.
percore hash table 방법은 direct-mapped cache 처럼 구현하여, 버켓에는 하나의 object만 존재하도록
만든 방법이다. 
만약 hash 충돌이 발생하면 기존 해당 코어의 log를 flush하는 일을 수행한다.
이것은 file reverse mapping 처럼 object가 많이 생기지 않을 때 유용하다. 
이 방법은 기존 코드에 대한 수정없이 적용이 가능하고 추가적인 lock이 필요없다.
하지만 이 방법은 anonymous reverse mapping 처럼 object가 많이 생기는 경우, hash 충돌로 인해 
성능상 오버헤드가 생긴다. 
따라서 anonymous reverse mapping의 percore queue는 percore data에 object별로
구분하지 않고 로그를 저장한 후 실제 percore log를 수행할 때 global lock을 사용하여 보호하였다. 
\else
%LDU percore queue는 2가지 방법으로 구현되었다. 
%첫번째 방법은 percore hash table로 구현하는 방법이다.
The implimentation of per-core queue in the LDU uses per-core hash table that 
can easily distinguish each object.
%percore hash table 방법은 direct-mapped cache 처럼 구현하여, 버켓에는 하나의 object만 존재하도록
%만든 방법이다. 
The LDU per-core hash table implemented as a direct-mapped cache, which one
bucket only has an object because recently used objects will be in the hash
table[Oplog].
%만약 hash 충돌이 발생하면 기존 해당 코어의 log를 flush하는 일을 수행한다.
When this hash table is met a hash conflict, the LDU evits the object in the
hash slot located in the per-core memory.
%이것은 file reverse mapping 처럼 object가 많이 생기지 않을 때 유용하다. 
This method is useful when the number of the root objects is small like the file
rmap(\code{struct address\_space}).
%이 방법은 기존 코드에 대한 수정없이 적용이 가능하고 추가적인 lock이 필요없다.
Moreover, this method reduce additional tasks of programers because it can
minimize code modifications and does not need additional locks.
%하지만 이 방법은 anonymous reverse mapping 처럼 object가 많이 생기는 경우, hash 충돌로 인해 성능상
% 오버헤드가 생긴다.
The per-core hash table, however, incurs a hash conflict overhead.
Since the anonymous rmap creates many of child root object(anon\_vma), so it
incurs a hash conflict overhead.
%따라서 anonymous reverse mapping의 percore queue는 percore data에 object별로 구분하지 않고
% 로그를 저장한 후 실제 percore log를 수행할 때 global lock을 사용하여 보호하였다.
In the case of the anonymous ramp, we do not distinguish object headers to
avoid the hash conflict overhead, but it needs addictional tasks with global
lock.
\fi

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Paragraph 3: object를 나중에 free하는 내용 설명 
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
% 기존 코드를 변경없이 




%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Reference Sentence 1
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$








%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Reference Sentence 2:LDU paper
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%\section{Implementation}\label{sec:implementation}
%We implemented the new deferred update algorithm in Linux 3.19.rc4 kernel, and
%our modified Linux is available as open source.
%\deferu's scheme is based on deferred processing, so it needs a garbage
%collector for delayed free.
%In order to implement the garbage collector, we use the lock-less list and a
%periodic timer(1 sec) in the Linux.

%Paragraph 2: 문제점을 해결하기 위해 Harris linked list를 적용
%We compare our \deferu implementation to a concurrent non-blocking Harris
%linked list ~\cite{Harris2001Lockfree};therefore, we implement the Harris
%% linked list to Linux kernel.
%The code refers from sysnchrobench~\cite{Gramoli2015Synchrobench} and
%ASCYLIB~\cite{David2015ASYNCHRONIZED}, and we convert their linked list to
%Linux kernel style.
%Because both synchrobench and ASCYLIB leak memory, we implement additional
%garbage collector for the Linux kernel using Linux's work queues and lock-less
%list.

%Paragraph 3: 오브젝트의 특징을 고려한 lock-free list 구현 
%In order to further improve performance, we move their ordered list to
%unordered list. 
%A feature of the Harris linked list is all the nodes are ordered by
%their key. 
%Zhang~\cite{zhang2013practical} implements a lock-free unordered list
%algorithm, whose list is each insert and remove operation appends an
%intermediate node at the head of the list;these approach is practically
%hard to implement.
%Indeed, Linux does not require contains operation because the Linux data
%structures such as list, tree and hash table not depended on search key;they
%depend on their unique object.
%This feature can eliminates the ordered list in Harris linked list.
%Therefore, we perform each insert operation appends an intermediate node at
%the first node of the list;on the other hand, each remove operation searches
%from head to their node.

%Paragraph 4: mapping은 DeferU와 Harris linked 리스트 둘 다 적용, 
%하지만 anon은 Harris Lined list 만 적용과 이유
%To the scalability of fork, the reverse mapping's lock contention should
%be eliminated not only from file reverse mapping but also from anonymous
% reverse mapping.
%The structure of file reverse mapping is simplified relatively to the
%structure of anonymous mapping because the anonymous reverse mapping is
%entangled by their global object(\code{anon\_vma}) and their
%chain(\code{anon\_vma\_chain});therefore, we only apply \deferu to file reverse
%mapping.

